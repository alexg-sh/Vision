// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                   String               @id @default(cuid())
  username             String?              @unique // Make username optional
  name                 String?
  email                String?              @unique
  emailVerified        DateTime?
  image                String?
  passwordHash         String? // Added for Credentials provider
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt
  accounts             Account[] // Added for NextAuth
  sessions             Session[] // Added for NextAuth
  organizations        OrganizationMember[]
  posts                Post[]
  comments             Comment[] // Add this line
  createdBoards        Board[]              @relation("CreatedBoards") // Add this line for the inverse relation
  bans                 OrganizationBan[] // Added inverse relation for bans
  sentInvites          Invite[]             @relation("SentInvites")
  receivedInvites      Invite[]             @relation("ReceivedInvites")
  notifications        Notification[]
  inviterNotifications Notification[]       @relation("InviterNotifications") // Separate relation name
  boardMembers         BoardMember[] // Add this relation
  auditLogs            AuditLog[] // Add this inverse relation for AuditLog
  bannedOrgActions     OrganizationBan[]    @relation("BannedByUsers") // Relation for bans issued by this user
  bannedBoardActions   BoardMember[]        @relation("BannedBoardUsers") // Relation for board bans issued by this user
  postVotes            PostVote[] // Added relation for PostVote
  commentVotes         CommentVote[] // Added relation for CommentVote
  // Add other fields as needed, e.g., passwordHash if using credentials
}

// Added for NextAuth
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

// Added for NextAuth
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userAgent    String? // Add this line to store the User-Agent string

  @@index([userId])
}

// Added for NextAuth
model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Organization {
  id            String               @id @default(cuid())
  name          String
  slug          String               @unique // For URL-friendly identifiers
  imageUrl      String?
  description   String? // Added description field
  isPrivate     Boolean              @default(false) // Add this line
  createdAt     DateTime             @default(now())
  updatedAt     DateTime             @updatedAt
  members       OrganizationMember[]
  boards        Board[]
  auditLogs     AuditLog[]
  bans          OrganizationBan[] // Added inverse relation for bans
  invites       Invite[]
  notifications Notification[]
}

// Junction table for many-to-many relationship between User and Organization
model OrganizationMember {
  id             String       @id @default(cuid())
  userId         String
  organizationId String
  role           String       @default("MEMBER") // e.g., ADMIN, MEMBER
  status         String       @default("ACTIVE") // e.g., ACTIVE, BANNED
  bannedAt       DateTime? // Timestamp when the user was banned
  banReason      String? // Optional reason for the ban
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@unique([userId, organizationId])
  @@index([userId])
  @@index([organizationId])
}

model OrganizationBan {
  id             String   @id @default(cuid())
  userId         String
  organizationId String
  bannedAt       DateTime @default(now())
  banReason      String?
  bannedByUserId String? // Changed from bannedBy: String?

  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  bannedBy     User?        @relation("BannedByUsers", fields: [bannedByUserId], references: [id], onDelete: SetNull) // Added relation

  @@unique([userId, organizationId])
  @@index([organizationId])
  @@index([bannedByUserId]) // Added index
}

model Board {
  id             String         @id @default(cuid())
  name           String
  description    String? // Added description field
  image          String? // Added image field
  isPrivate      Boolean        @default(false) // Added isPrivate field
  organizationId String? // Make organizationId optional
  createdById    String // Foreign key for the creator
  organization   Organization?  @relation(fields: [organizationId], references: [id], onDelete: Cascade) // Adjust relation to be optional
  createdBy      User           @relation("CreatedBoards", fields: [createdById], references: [id], onDelete: Cascade)
  posts          Post[]
  invites        Invite[]
  notifications  Notification[]
  members        BoardMember[] // Add this relation
  auditLogs      AuditLog[] // Added inverse relation
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  @@index([organizationId])
  @@index([createdById])
}

// Add the BoardMember model here
model BoardMember {
  id             String    @id @default(cuid())
  userId         String
  boardId        String
  role           String    @default("MEMBER") // e.g., ADMIN, MEMBER, VIEWER
  status         String    @default("ACTIVE") // Added: e.g., ACTIVE, BANNED
  bannedAt       DateTime? // Added: Timestamp when the user was banned from the board
  banReason      String?   // Added: Optional reason for the board ban
  bannedByUserId String?   // Added: Admin/Mod who banned from board
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  user     User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  board    Board @relation(fields: [boardId], references: [id], onDelete: Cascade)
  bannedBy User? @relation("BannedBoardUsers", fields: [bannedByUserId], references: [id], onDelete: SetNull) // Added relation

  @@unique([userId, boardId])
  @@index([userId])
  @@index([boardId])
  @@index([bannedByUserId]) // Added index
}

model Post {
  id            String         @id @default(cuid())
  title         String
  content       String?
  boardId       String
  board         Board          @relation(fields: [boardId], references: [id], onDelete: Cascade)
  authorId      String
  author        User           @relation(fields: [authorId], references: [id], onDelete: Cascade)
  votes         Int            @default(0)  // Added votes field
  comments      Comment[]
  postVotes     PostVote[] // Added relation for PostVote
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  notifications Notification[]

  @@index([boardId])
  @@index([authorId])
}

model Comment {
  id         String   @id @default(cuid())
  postId     String
  post       Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  authorId   String
  author     User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  content    String
  votes      Int      @default(0)
  commentVotes CommentVote[] // Added relation for CommentVote
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model PostVote {
  id        String   @id @default(cuid())
  userId    String
  postId    String
  voteType  Int      // 1 for like, -1 for dislike
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
  @@index([postId])
}

model CommentVote {
  id        String   @id @default(cuid())
  userId    String
  commentId String
  voteType  Int      // 1 for like, -1 for dislike
  createdAt DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@unique([userId, commentId])
  @@index([commentId])
}

// Example Audit Log model
model AuditLog {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  boardId        String? // Added: Optional board ID
  board          Board?       @relation(fields: [boardId], references: [id], onDelete: Cascade) // Added: Optional relation to Board
  userId         String? // User who performed the action (optional, for system actions)
  user           User?        @relation(fields: [userId], references: [id], onDelete: SetNull) // Relation to User
  action         String // e.g., "BAN_USER", "CREATE_BOARD", "UPDATE_POST"
  entityType     String // e.g., "USER", "BOARD", "POST"
  entityId       String? // ID of the entity affected (e.g., userId, boardId, postId)
  details        Json? // Additional details about the action (e.g., ban reason, old/new role)
  createdAt      DateTime     @default(now())

  @@index([organizationId])
  @@index([boardId]) // Added index
  @@index([userId])
  @@index([entityType, entityId]) // Added index for easier lookup of actions on specific entities
}

model Notification {
  id        String           @id @default(cuid())
  userId    String // The ID of the user receiving the notification
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      NotificationType
  content   String
  link      String? // Link to the relevant page (post, board, org, etc.)
  read      Boolean          @default(false)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt // Remove @default()

  // Optional fields for specific notification types
  inviterId String? // ID of the user who sent the invite/mention etc.
  inviter   User?   @relation("InviterNotifications", fields: [inviterId], references: [id], onDelete: SetNull) // Separate relation name

  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  boardId String?
  board   Board?  @relation(fields: [boardId], references: [id], onDelete: Cascade)

  postId String?
  post   Post?   @relation(fields: [postId], references: [id], onDelete: Cascade)

  inviteId String? @unique // Link to the specific invite
  invite   Invite? @relation(fields: [inviteId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, read])
}

enum NotificationType {
  MENTION
  REPLY
  VOTE
  STATUS_UPDATE // Renamed from STATUS for clarity
  ANNOUNCEMENT
  POLL_CREATED // Renamed from POLL for clarity
  INVITE // Added for invitations
  // Add other types as needed
}

model Invite {
  id              String       @id @default(cuid())
  invitedUsername String? // Make optional
  status          InviteStatus @default(PENDING)
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  invitedById String // ID of the user who sent the invite
  invitedBy   User   @relation("SentInvites", fields: [invitedById], references: [id], onDelete: Cascade)

  // Link to either an organization OR a board, not both typically
  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  boardId String?
  board   Board?  @relation(fields: [boardId], references: [id], onDelete: Cascade)

  // Optional: Link to the user account once they accept/exist
  invitedUserId String?
  invitedUser   User?   @relation("ReceivedInvites", fields: [invitedUserId], references: [id], onDelete: Cascade)

  notification Notification? // The notification associated with this invite

  // Adjust unique constraints for nullable field
  @@unique([invitedUsername, organizationId], name: "unique_org_invite_per_user")
  @@unique([invitedUsername, boardId], name: "unique_board_invite_per_user")
  @@index([invitedUserId])
  @@index([organizationId])
  @@index([boardId])
}

enum InviteStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED // Optional
}

// Make sure OrganizationMember and BoardMember models exist and are correctly defined
// Example (adjust based on your actual schema):
// Removed duplicate definitions below

// Add other models as needed, e.g., Notification, CustomField, etc.
