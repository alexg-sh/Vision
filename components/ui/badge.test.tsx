import { render, screen } from '@testing-library/react'
import { Badge, badgeVariants, BadgeProps } from './badge' // Import BadgeProps

describe('Badge component', () => {
  it('renders its children', () => {
    render(<Badge>Test Badge</Badge>)
    expect(screen.getByText('Test Badge')).toBeInTheDocument()
  })

  // Test different variants
  // Define the variants explicitly with the correct type
  const variants: NonNullable<BadgeProps['variant']>[] = [
    'default',
    'secondary',
    'destructive',
    'outline',
  ]
  variants.forEach((variant) => {
    it(`renders correctly with variant: ${variant}`, () => {
      render(<Badge variant={variant}>Variant Badge</Badge>)
      const badge = screen.getByText('Variant Badge')
      expect(badge).toBeInTheDocument()
      // Check if the base and variant-specific classes are applied
      // Note: This requires knowing the exact classes generated by cva, which can be brittle.
      // A more robust approach might involve snapshot testing or checking computed styles.
      expect(badge).toHaveClass(badgeVariants({ variant }))
    })
  })

  it('applies additional className props', () => {
    render(<Badge className="extra-class">Classy Badge</Badge>)
    const badge = screen.getByText('Classy Badge')
    expect(badge).toHaveClass('extra-class')
    expect(badge).toHaveClass(badgeVariants({ variant: 'default' })) // Should still have default variant class
  })

  it('passes other HTML attributes', () => {
    render(<Badge data-testid="my-badge" id="badge-id">Attribute Badge</Badge>)
    const badge = screen.getByText('Attribute Badge')
    expect(badge).toHaveAttribute('id', 'badge-id')
    expect(screen.getByTestId('my-badge')).toBeInTheDocument()
  })
})